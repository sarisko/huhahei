{% extends "huhahei/base.html" %}

{% block title %}Game{% endblock %}

{% block content %}
<h1>Hello player!</h1>

<p>
    You are playing {{ game.title}}
    (<a href="{% url 'board' game_id=game.id %}">leaderboard</a>)
</p>

<p>
    Your best score is <span id="top_score">{{ player.top_score }}</span>
</p>

<form>
    {% csrf_token %}
    <label for="{{ name_form.name.id_for_label }}">Name: </label>
    {{ name_form.name }}
    <button hx-post="{% url 'update-name' game_id=game.id %}" hx-include="closest form" hx-target="#messages"
        hx-swap="afterbegin">Save</button>
</form>

<p>
    {% csrf_token %}
    Generate random score:
    <button hx-post="{% url 'submit' game_id=game.id %}" hx-include="closest p" hx-target="#messages"
        hx-swap="afterbegin">Submit</button>
</p>
<hr />

{% if debug|default_if_none:'true' == 'true' %}
<button id="startbutton" onclick="start()">
    Start
</button>
<h1 style="user-select:none;" id="record" ontouchstart="touchstart()" ontouchend="touchend()">
    RECORD
</h1>
<p id="logs">debug logs here</p>
<p id="detectlogs">detect logs here</p>
{% endif %}

<!-- big detection script doing big brain comments may be useful -->
<script>
    function start() {
        // Request permission for iOS 13+ devices
        // this needs to happen after user interaction, otherwise iphones
        // won't let you record accelerometer data
        if (
            DeviceMotionEvent &&
            typeof DeviceMotionEvent.requestPermission === "function"
        ) {
            DeviceMotionEvent.requestPermission();
            // ignore the case of denial :D
        }

        window.addEventListener("devicemotion", motionHandler);
        window.addEventListener("deviceorientation", (event) => {
            if (!recording) return;
            dataRot.push({x: event.alpha, y: event.beta, z: event.gamma});
        });
        recording = true;
        document.getElementById('startbutton').style.display = 'none';
    }
    // Here are some global variables which are used as state storage
    let debugCountEntries = 0;
    let debugTimeElapsed = 0;
    let lastAccTimestamp = 0;
    let data = []; // this array contains the acceleration data, it is also wiped to [] everytime we find a gesture
    let dataRot = []; // same for deviceorientation event (angular velocity)
    let recording = false; // This is essentially true all the time after we get permissions
    // This is the main function which runs 60xps, captures acc data
    function motionHandler(event) {
        if (lastAccTimestamp === 0) lastAccTimestamp = Date.now();

        const acceleration = event.acceleration;
        debugCountEntries++;
        debugTimeElapsed += Date.now() - lastAccTimestamp;
        lastAccTimestamp = Date.now();

        document.getElementById("logs").innerHTML =
            "<br>MPS:" + Math.round((debugCountEntries / debugTimeElapsed) * 1000);
        if (recording) data.push(acceleration);
    }
    // This function runs on setInterval below, and detects calibration/later gestures from data
    let lastDetectTimestamp = 0;
    const gestLength = 80;
    const gestThreshold = 500;
    const repr = {
        'up': null,
        'side': null,
        'forward': null,
    }
    function dataDetection() {
        if (!recording) return;
        if (data.length < gestLength) return;

        const magnitude = getMagnitude(data.length - gestLength, data.length);
        if (magnitude > gestThreshold) {
            document.getElementById("detectlogs").innerHTML +=
                "<br>L" + data.length + " M" + magnitude +
                " " + (Date.now() - lastDetectTimestamp)
            // If we do not have repr filled, it means we are in a calibration stage, so
            // every time we detect a gesture we want to fill another repr. entry
            calibration: {
                if (repr.up === null) {
                    repr.up = [
                        zeroMeanUnitVarianceNormalization(data.slice(data.length - gestLength, data.length)),
                        zeroMeanUnitVarianceNormalization(dataRot.slice(dataRot.length - gestLength, dataRot.length))
                    ]
                    document.getElementById("detectlogs").innerHTML += "-> upC";
                    break calibration;
                }
                if (repr.side === null) {
                    repr.side = [
                        zeroMeanUnitVarianceNormalization(data.slice(data.length - gestLength, data.length)),
                        zeroMeanUnitVarianceNormalization(dataRot.slice(dataRot.length - gestLength, dataRot.length))
                    ]
                    document.getElementById("detectlogs").innerHTML += "-> sideC";
                    break calibration;
                }
                if (repr.forward === null) {
                    repr.forward = [
                        zeroMeanUnitVarianceNormalization(data.slice(data.length - gestLength, data.length)),
                        zeroMeanUnitVarianceNormalization(dataRot.slice(dataRot.length - gestLength, dataRot.length))
                    ]
                    document.getElementById("detectlogs").innerHTML += "-> forwardC";
                    break calibration;
                }
            }
            detection: {
                if (repr.up === null || repr.side === null || repr.forward === null) break detection;
                const closest = getClosest();
                document.getElementById("detectlogs").innerHTML += "-> det: " + closest;
                console.log('closest', closest)
            }

            // cleanup after ourselves, just a memory thing, we anyway look only
            // at the last 50 entries. 
            data = [];
            dataRot = [];
            lastDetectTimestamp = Date.now();


        }
    }
    setInterval(dataDetection, 1000 / 6);
    // helper function for gesture detection
    function getMagnitude(i_start, i_end) {
        // gets the total magnitude between indices from data
        let sum = 0;
        for (let i = i_start; i < i_end; i++) {
            sum += Math.sqrt(
                data[i].x * data[i].x + data[i].y * data[i].y + data[i].z * data[i].z,
            );
        }
        return Math.round(sum, 3);
    }
    // helper function for detecting distance between two vectors
    // gets just repr so that we don't doo too much array copying
    // function getDistance(reprName) {
    //     const reprRef = repr[reprName];
    //     const startIndex = data.length - gestLength;
    //     let dist = 0;
    //     // euc dist
    //     /* for (let i = startIndex; i < data.length; ++i) {
    //         const reprIndex = i - startIndex;
    //         dist += Math.sqrt(
    //             (data[i].x - reprRef[reprIndex].x) * (data[i].x - reprRef[reprIndex].x) +
    //             (data[i].y - reprRef[reprIndex].y) * (data[i].y - reprRef[reprIndex].y) +
    //             (data[i].z - reprRef[reprIndex].z) * (data[i].z - reprRef[reprIndex].z),
    //         )
    //     } */
    //     // cosine dist only from acc data
    //     for (let m = 0; m < 1; ++m) {
    //         for (let i = startIndex; i < data.length; ++i) {
    //             const reprIndex = i - startIndex;
    //             const reprMag = Math.sqrt(
    //                 reprRef[m][reprIndex].x * reprRef[m][reprIndex].x +
    //                 reprRef[m][reprIndex].y * reprRef[m][reprIndex].y +
    //                 reprRef[m][reprIndex].z * reprRef[m][reprIndex].z,
    //             );
    //             const dataMag = Math.sqrt(
    //                 data[i].x * data[i].x +
    //                 data[i].y * data[i].y +
    //                 data[i].z * data[i].z,
    //             );
    //             const dot = (
    //                 data[i].x * reprRef[m][reprIndex].x +
    //                 data[i].y * reprRef[m][reprIndex].y +
    //                 data[i].z * reprRef[m][reprIndex].z
    //             );
    //             dist += Math.acos(dot / (reprMag * dataMag));
    //         }
    //     }
    //     let distRot = 0;
    //     // from rotation we take euclidean distance
    //     for (let i = startIndex; i < data.length; ++i) {
    //         const reprIndex = i - startIndex;
    //         distRot += (dataRot[i].x - reprRef[1][reprIndex].x) * (dataRot[i].x - reprRef[1][reprIndex].x) +
    //             (dataRot[i].y - reprRef[1][reprIndex].y) * (dataRot[i].y - reprRef[1][reprIndex].y) +
    //             (dataRot[i].z - reprRef[1][reprIndex].z) * (dataRot[i].z - reprRef[1][reprIndex].z)
    //
    //     }
    //
    //     distRot = Math.round(distRot, 3);
    //     dist = Math.round(dist, 3);
    //
    //     // return dist
    //     // return distRot / 80 + dist;
    //     return distRot;
    // }

    function getDistance(reprName) {
        const reprRef = repr[reprName];
        const startIndex = data.length - gestLength;
        let dist = 0;
        let distRot = 0;

        // Normalize acceleration and rotation data
        const normalizedData = zeroMeanUnitVarianceNormalization(data.slice(startIndex, data.length));
        const normalizedDataRot = zeroMeanUnitVarianceNormalization(dataRot.slice(startIndex, dataRot.length));

        // Cosine distance from normalized acc data
        /* for (let i = 0; i < normalizedData.length; ++i) {
            const dotProduct = (
                normalizedData[i].x * reprRef[0][i].x +
                normalizedData[i].y * reprRef[0][i].y +
                normalizedData[i].z * reprRef[0][i].z
            );
            dist += Math.abs(dotProduct)
        } */
        // Euclidean distance from normalized acc data
        for (let i = 0; i < normalizedData.length; ++i) {
            dist += Math.sqrt(
                Math.pow(normalizedData[i].x - reprRef[0][i].x, 2) +
                Math.pow(normalizedData[i].y - reprRef[0][i].y, 2) +
                Math.pow(normalizedData[i].z - reprRef[0][i].z, 2)
            );
        }

        // Euclidean distance from normalized rotation data
        for (let i = 0; i < normalizedDataRot.length; ++i) {
            distRot += Math.sqrt(
                Math.pow(normalizedDataRot[i].x - reprRef[1][i].x, 2) +
                Math.pow(normalizedDataRot[i].y - reprRef[1][i].y, 2) +
                Math.pow(normalizedDataRot[i].z - reprRef[1][i].z, 2)
            );
        }
        console.log('reprName', reprName, 'dist', dist, 'distRot', distRot)
        return [dist, distRot]
    }
    // helper function to get distances from three representatives and return the label of the closest
    function getClosest() {
        const [distUpAcc, distUpRot] = getDistance('up');
        const [distSideAcc, distSideRot] = getDistance('side');
        const [distForwardAcc, distForwardRot] = getDistance('forward');
        // if the euclidean distance on acc is <100 we just slap it on straight away.
        if (distUpAcc < 100 || distSideAcc < 100 || distForwardAcc < 100) {
            if (distUpAcc < distSideAcc && distUpAcc < distForwardAcc) return ['up', distUpAcc, 'side', distSideAcc, 'forward', distForwardAcc]
            if (distSideAcc < distUpAcc && distSideAcc < distForwardAcc) return ['side', distSideAcc, 'up', distUpAcc, 'forward', distForwardAcc]
            return ['forward', distForwardAcc, 'up', distUpAcc, 'side', distSideAcc]
        }
        // same for rot
        if (distUpRot < 100 || distSideRot < 100 || distForwardRot < 100) {
            if (distUpRot < distSideRot && distUpRot < distForwardRot) return ['up', distUpRot, 'side', distSideRot, 'forward', distForwardRot]
            if (distSideRot < distUpRot && distSideRot < distForwardRot) return ['side', distSideRot, 'up', distUpRot, 'forward', distForwardRot]
            return ['forward', distForwardRot, 'up', distUpRot, 'side', distSideRot]
        }
        //otherwise weigh half half
        const distUp = distUpAcc + distUpRot;
        const distSide = distSideAcc + distSideRot;
        const distForward = distForwardAcc + distForwardRot;
        if (distUp < distSide && distUp < distForward) return ['up', distUp, 'side', distSide, 'forward', distForward]
        if (distSide < distUp && distSide < distForward) return ['side', distSide, 'up', distUp, 'forward', distForward]
        return ['forward', distForward, 'up', distUp, 'side', distSide]
    }

    function zeroMeanUnitVarianceNormalization(data) {
        const mean = {x: 0, y: 0, z: 0};
        const variance = {x: 0, y: 0, z: 0};

        for (const vector of data) {
            mean.x += vector.x;
            mean.y += vector.y;
            mean.z += vector.z;
        }

        mean.x /= data.length;
        mean.y /= data.length;
        mean.z /= data.length;

        for (const vector of data) {
            variance.x += Math.pow(vector.x - mean.x, 2);
            variance.y += Math.pow(vector.y - mean.y, 2);
            variance.z += Math.pow(vector.z - mean.z, 2);
        }

        variance.x /= data.length;
        variance.y /= data.length;
        variance.z /= data.length;

        const standardDeviation = {
            x: Math.sqrt(variance.x),
            y: Math.sqrt(variance.y),
            z: Math.sqrt(variance.z),
        };

        const normalizedData = data.map(vector => ({
            x: (vector.x - mean.x) / standardDeviation.x,
            y: (vector.y - mean.y) / standardDeviation.y,
            z: (vector.z - mean.z) / standardDeviation.z,
        }));

        return normalizedData;
    }
    // There are just helper functions for dataset recording
    function touchstart() {
        data = [];
        recording = true;
        document.getElementById("record").style.backgroundColor = "red";
    }
    let gestureNo = 0;
    function touchend() {
        recording = false;
        document.getElementById("record").style.backgroundColor = "white";
        gestureNo++;
        const filename = "gesture" + gestureNo + ".csv";
        let csvContent = "data:text/csv;charset=utf-8," + gestureNo + "\n";
        data.forEach(function (dataMember) {
            csvContent += dataMember.x + "," + dataMember.y + "," + dataMember.z;
            csvContent += "\n";
        });

        const element = document.createElement("a");
        element.setAttribute(
            "href",
            "data:text/plain;charset=utf-8," + encodeURIComponent(csvContent),
        );
        element.setAttribute("download", filename);

        element.style.display = "none";
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }
</script>

<hr />

<ul id="messages"></ul>

{% endblock %}
